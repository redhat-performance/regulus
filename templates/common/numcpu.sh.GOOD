#!/bin/bash
#
# Compute number of CPU to be allocated per pod
#   $number_cpus is the total useable cpus per worker node.
#   $CORE_PERSOCKET is the number of CPUs per socket.
#   $topo variable with 2 valid values (internode and intranode)
#   $scale_up_factor is a variable specifying how many pods per worker node. 
#       if internode the number of pods=$scale_up_factor if internode the number of pods=$scale_up_factor. 
#        If intranode the number of pods=2*scale_up_factor
#   $TPL_NUMCPUS (range 0-n) is user-demanded number of CPUs per pod.
#   $TPL_QOS an user-defined pod OQS mode (valid values are burstable or guarantee)
#   $numa_mode (single-numa-node or none) - When single numa, we can only allocate from ine socket thus we use $CORE_PERSOCKET.
#
#   The computation logic can have either compute-fit or fit.
#        compute-fit finds the larger number of CPU per pod possible. 
#         Fit is just check to see if the user-demanded number of CPUs will not exceed.
#   The truth table of two computation methods: compute-fit and fit
#
#   TPL_NUMCPUS         TPL_QOS
#       0           burstable  compute-fit (fill to the max CPU)
#       0           guaranteed compute-fit
#       N           burstable  fit  (error if over filled
#       N           guaranteed fit (error if over filled
#
#  Additional rules: 
#       single-numa-node only effect guranteed pods
#       Guranteed pod must have whole core(s)
#           
#

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Test counter
TOTAL_TESTS=0
PASSED_TESTS=0
FAILED_TESTS=0

# Helper function to calculate number of pods based on topology
calculate_num_pods() {
    local topo=$1
    local scale_up_factor=$2
    
    if [[ "$topo" == "internode" ]]; then
        echo "$scale_up_factor"
    elif [[ "$topo" == "intranode" ]]; then
        echo "$((scale_up_factor * 2))"
    else
        echo "Error: Invalid topology value: $topo" >&2
        return 1
    fi
}

# Helper function to round down to nearest multiple (for full cores)
# Ensures CPUs allocated are multiples of cpus_per_core
round_down_to_full_cores() {
    local num=$1
    local cpus_per_core=$2
    echo "$(( (num / cpus_per_core) * cpus_per_core ))"
}

# Helper function to calculate maximum available CPUs per pod
calculate_max_cpus_per_pod() {
    local number_cpus=$1
    local num_pods=$2
    local numa_mode=$3
    local core_per_socket=$4
    local tpl_qos=$5
    local cpus_per_core=$6
    
    local available_cpus
    # CRITICAL: Burstable mode is NOT constrained by single-numa-node
    if [[ "$numa_mode" == "single-numa-node" && "$tpl_qos" == "guaranteed" ]]; then
        available_cpus=$core_per_socket
    else
        available_cpus=$number_cpus
    fi
    
    # Integer division for max CPUs per pod
    local max_cpus=$(( available_cpus / num_pods ))
    
    # CRITICAL: Guaranteed pods must use full cores (multiple of cpus_per_core)
    if [[ "$tpl_qos" == "guaranteed" ]]; then
        max_cpus=$(round_down_to_full_cores $max_cpus $cpus_per_core)
        
        # CRITICAL: Guaranteed pods must have at least one full core
        if [[ $max_cpus -lt $cpus_per_core ]]; then
            echo "Error: Not enough CPUs to allocate at least one full core per pod" >&2
            echo "  Available CPUs: $available_cpus" >&2
            echo "  Number of pods: $num_pods" >&2
            echo "  CPUs per core: $cpus_per_core" >&2
            echo "  Result would be: $max_cpus CPUs per pod (less than one full core)" >&2
            return 1
        fi
    fi
    
    echo "$max_cpus"
}

# Main function to compute CPUs per pod
compute_cpus_per_pod() {
    local number_cpus=$1
    local core_per_socket=$2
    local topo=$3
    local scale_up_factor=$4
    local tpl_numcpus=$5
    local tpl_qos=$6
    local numa_mode=$7
    local cpus_per_core=${8:-2}  # Default to 2 (hyperthreading enabled)
    
    # Calculate number of pods
    local num_pods
    num_pods=$(calculate_num_pods "$topo" "$scale_up_factor")
    if [[ $? -ne 0 ]]; then
        return 1
    fi
    
    # Calculate max available CPUs per pod
    local max_cpus_per_pod
    max_cpus_per_pod=$(calculate_max_cpus_per_pod "$number_cpus" "$num_pods" "$numa_mode" "$core_per_socket" "$tpl_qos" "$cpus_per_core" 2>&1)
    local calc_result=$?
    
    if [[ $calc_result -ne 0 ]]; then
        echo "$max_cpus_per_pod"
        return 1
    fi
    
    # Determine computation method based on truth table
    if [[ $tpl_numcpus -eq 0 ]]; then
        # compute-fit: fill to the max CPU
        echo "$max_cpus_per_pod"
    else
        # fit: check if user-demanded CPUs fit
        
        # CRITICAL: For guaranteed mode, validate that requested CPUs is a multiple of cpus_per_core (full cores)
        if [[ "$tpl_qos" == "guaranteed" ]]; then
            if [[ $((tpl_numcpus % cpus_per_core)) -ne 0 ]]; then
                echo "Error: Guaranteed pods must request CPUs in multiples of $cpus_per_core (full cores)" >&2
                echo "  Requested: $tpl_numcpus CPUs (not a multiple of $cpus_per_core)" >&2
                return 1
            fi
            
            if [[ $tpl_numcpus -lt $cpus_per_core ]]; then
                echo "Error: Guaranteed pods must request at least $cpus_per_core CPUs (one full core)" >&2
                echo "  Requested: $tpl_numcpus CPUs" >&2
                return 1
            fi
        fi
        
        if [[ $tpl_numcpus -le $max_cpus_per_pod ]]; then
            echo "$tpl_numcpus"
        else
            echo "Error: Requested $tpl_numcpus CPUs per pod exceeds maximum available $max_cpus_per_pod CPUs per pod" >&2
            echo "  Total available CPUs: $number_cpus" >&2
            echo "  Number of pods: $num_pods" >&2
            echo "  NUMA mode: $numa_mode" >&2
            echo "  QoS mode: $tpl_qos" >&2
            echo "  CPUs per core: $cpus_per_core" >&2
            return 1
        fi
    fi
}

# Test function
run_test() {
    local test_name=$1
    local number_cpus=$2
    local core_per_socket=$3
    local topo=$4
    local scale_up_factor=$5
    local tpl_numcpus=$6
    local tpl_qos=$7
    local numa_mode=$8
    local cpus_per_core=$9
    local expected_result=${10}
    local should_fail=${11:-false}
    
    TOTAL_TESTS=$((TOTAL_TESTS + 1))
    
    echo -e "\n${YELLOW}Test $TOTAL_TESTS: $test_name${NC}"
    echo "  Parameters:"
    echo "    number_cpus=$number_cpus, core_per_socket=$core_per_socket, cpus_per_core=$cpus_per_core"
    echo "    topo=$topo, scale_up_factor=$scale_up_factor"
    echo "    tpl_numcpus=$tpl_numcpus, tpl_qos=$tpl_qos, numa_mode=$numa_mode"
    
    result=$(compute_cpus_per_pod "$number_cpus" "$core_per_socket" "$topo" "$scale_up_factor" "$tpl_numcpus" "$tpl_qos" "$numa_mode" "$cpus_per_core" 2>&1)
    exit_code=$?
    
    if [[ "$should_fail" == "true" ]]; then
        if [[ $exit_code -ne 0 ]]; then
            echo -e "  ${GREEN}✓ PASSED${NC} - Failed as expected"
            echo "  Error message: $result"
            PASSED_TESTS=$((PASSED_TESTS + 1))
        else
            echo -e "  ${RED}✗ FAILED${NC} - Expected failure but succeeded with: $result"
            FAILED_TESTS=$((FAILED_TESTS + 1))
        fi
    else
        if [[ $exit_code -eq 0 ]]; then
            if [[ "$result" == "$expected_result" ]]; then
                echo -e "  ${GREEN}✓ PASSED${NC} - Got expected result: $result"
                PASSED_TESTS=$((PASSED_TESTS + 1))
            else
                echo -e "  ${RED}✗ FAILED${NC} - Expected: $expected_result, Got: $result"
                FAILED_TESTS=$((FAILED_TESTS + 1))
            fi
        else
            echo -e "  ${RED}✗ FAILED${NC} - Unexpected error: $result"
            FAILED_TESTS=$((FAILED_TESTS + 1))
        fi
    fi
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    # script being execute directly.
    
    echo "=========================================="
    echo "CPU per Pod Computation Test Suite"
    echo "=========================================="
    echo "Testing with cpus_per_core=2 (hyperthreading)"
    echo "=========================================="
    
    # Test Case 1: compute-fit with TPL_NUMCPUS=0, burstable, internode, none, HT=2
    run_test "compute-fit: 0 CPUs requested, burstable, internode, none, HT=2" \
        64 32 "internode" 4 0 "burstable" "none" 2 16
    
    # Test Case 2: compute-fit with TPL_NUMCPUS=0, guaranteed, internode, none, HT=2 (must be multiple of 2)
    run_test "compute-fit: 0 CPUs requested, guaranteed, internode, none, HT=2 (multiple of 2)" \
        64 32 "internode" 4 0 "guaranteed" "none" 2 16
    
    # Test Case 3: compute-fit with TPL_NUMCPUS=0, burstable, intranode, none, HT=2
    run_test "compute-fit: 0 CPUs requested, burstable, intranode, none, HT=2" \
        64 32 "intranode" 4 0 "burstable" "none" 2 8
    
    # Test Case 4: compute-fit with TPL_NUMCPUS=0, guaranteed, intranode, none, HT=2 (multiple of 2)
    run_test "compute-fit: 0 CPUs requested, guaranteed, intranode, none, HT=2 (multiple of 2)" \
        64 32 "intranode" 4 0 "guaranteed" "none" 2 8
    
    # Test Case 5: compute-fit with TPL_NUMCPUS=0, burstable, internode, single-numa-node, HT=2
    run_test "compute-fit: 0 CPUs requested, burstable, internode, single-numa-node, HT=2 (NOT constrained)" \
        64 32 "internode" 4 0 "burstable" "single-numa-node" 2 16
    
    # Test Case 6: compute-fit with TPL_NUMCPUS=0, guaranteed, internode, single-numa-node, HT=2
    run_test "compute-fit: 0 CPUs requested, guaranteed, internode, single-numa-node, HT=2 (constrained)" \
        64 32 "internode" 4 0 "guaranteed" "single-numa-node" 2 8
    
    # Test Case 7: compute-fit with TPL_NUMCPUS=0, burstable, intranode, single-numa-node, HT=2
    run_test "compute-fit: 0 CPUs requested, burstable, intranode, single-numa-node, HT=2 (NOT constrained)" \
        64 32 "intranode" 4 0 "burstable" "single-numa-node" 2 8
    
    # Test Case 8: compute-fit with TPL_NUMCPUS=0, guaranteed, intranode, single-numa-node, HT=2
    run_test "compute-fit: 0 CPUs requested, guaranteed, intranode, single-numa-node, HT=2 (constrained)" \
        64 32 "intranode" 4 0 "guaranteed" "single-numa-node" 2 4
    
    # Test Case 9: fit - odd number request, burstable, HT=2 (allowed)
    run_test "fit: 7 CPUs requested (odd, valid for burstable), burstable, HT=2" \
        64 32 "internode" 4 7 "burstable" "none" 2 7
    
    # Test Case 10: fit - multiple of 2 request, guaranteed, HT=2 (allowed)
    run_test "fit: 12 CPUs requested (multiple of 2, valid), guaranteed, HT=2" \
        64 32 "internode" 4 12 "guaranteed" "none" 2 12
    
    # Test Case 11: fit - odd number request, guaranteed, HT=2 (SHOULD FAIL - not full cores)
    run_test "fit: 7 CPUs requested (odd, invalid for guaranteed), guaranteed, HT=2" \
        64 32 "internode" 4 7 "guaranteed" "none" 2 "" true
    
    # Test Case 12: fit - multiple of 2 at exact limit, guaranteed, HT=2
    run_test "fit: 16 CPUs requested (multiple of 2, at limit), guaranteed, HT=2" \
        64 32 "internode" 4 16 "guaranteed" "none" 2 16
    
    # Test Case 13: fit - 2 CPUs requested (1 full core with HT=2), guaranteed
    run_test "fit: 2 CPUs requested (1 full core, HT=2), guaranteed" \
        64 32 "internode" 8 2 "guaranteed" "none" 2 2
    
    # Test Case 14: fit - 1 CPU requested, guaranteed, HT=2 (SHOULD FAIL - not full core)
    run_test "fit: 1 CPU requested (not full core, HT=2), guaranteed" \
        64 32 "internode" 8 1 "guaranteed" "none" 2 "" true
    
    # Test Case 15: fit - 1 CPU requested, burstable, HT=2 (allowed)
    run_test "fit: 1 CPU requested, burstable, HT=2 (allowed)" \
        64 32 "internode" 8 1 "burstable" "none" 2 1
    
    # Test Case 16: compute-fit resulting in odd, guaranteed rounds down, HT=2
    # 63 CPUs / 7 pods = 9, guaranteed rounds down to 8 (multiple of 2)
    run_test "Results in 9, guaranteed rounds to 8, HT=2: 63 / 7" \
        63 32 "internode" 7 0 "guaranteed" "none" 2 8
    
    # Test Case 17: compute-fit resulting in odd, burstable keeps odd, HT=2
    # 63 CPUs / 7 pods = 9, burstable keeps 9
    run_test "Results in 9, burstable keeps 9, HT=2: 63 / 7" \
        63 32 "internode" 7 0 "burstable" "none" 2 9
    
    echo -e "\n=========================================="
    echo "Testing with cpus_per_core=4 (4-way SMT)"
    echo "=========================================="
    
    # Test Case 18: compute-fit, guaranteed, HT=4 (must be multiple of 4)
    # 64 CPUs / 4 pods = 16 (multiple of 4)
    run_test "compute-fit: guaranteed, HT=4, 64/4=16" \
        64 32 "internode" 4 0 "guaranteed" "none" 4 16
    
    # Test Case 19: compute-fit with result not multiple of 4, guaranteed, HT=4
    # 64 CPUs / 5 pods = 12.8 -> 12 (rounds down to 12, multiple of 4)
    run_test "compute-fit: guaranteed, HT=4, 64/5=12 (rounded to multiple of 4)" \
        64 32 "internode" 5 0 "guaranteed" "none" 4 12
    
    # Test Case 20: compute-fit with result=14, guaranteed rounds to 12, HT=4
    # 70 CPUs / 5 pods = 14, rounds down to 12 (multiple of 4)
    run_test "compute-fit: guaranteed, HT=4, 70/5=14 rounds to 12" \
        70 35 "internode" 5 0 "guaranteed" "none" 4 12
    
    # Test Case 21: fit - request 8 CPUs (2 full cores with HT=4), guaranteed
    run_test "fit: 8 CPUs requested (2 full cores, HT=4), guaranteed" \
        64 32 "internode" 4 8 "guaranteed" "none" 4 8
    
    # Test Case 22: fit - request 6 CPUs (not multiple of 4), guaranteed, HT=4 (SHOULD FAIL)
    run_test "fit: 6 CPUs requested (not multiple of 4, HT=4), guaranteed" \
        64 32 "internode" 4 6 "guaranteed" "none" 4 "" true
    
    # Test Case 23: fit - request 6 CPUs, burstable, HT=4 (allowed)
    run_test "fit: 6 CPUs requested, burstable, HT=4 (allowed)" \
        64 32 "internode" 4 6 "burstable" "none" 4 6
    
    # Test Case 24: compute-fit with single-numa-node, guaranteed, HT=4
    # 32 CPUs per socket / 5 pods = 6.4 -> 4 (multiple of 4)
    run_test "compute-fit: single-numa-node, guaranteed, HT=4, 32/5=4" \
        64 32 "internode" 5 0 "guaranteed" "single-numa-node" 4 4
    
    echo -e "\n=========================================="
    echo "Testing with cpus_per_core=1 (no hyperthreading)"
    echo "=========================================="
    
    # Test Case 25: compute-fit, guaranteed, HT=1 (no rounding needed)
    run_test "compute-fit: guaranteed, HT=1, 64/4=16" \
        64 32 "internode" 4 0 "guaranteed" "none" 1 16
    
    # Test Case 26: compute-fit with odd result, guaranteed, HT=1
    # 64 CPUs / 5 pods = 12.8 -> 12
    run_test "compute-fit: guaranteed, HT=1, 64/5=12" \
        64 32 "internode" 5 0 "guaranteed" "none" 1 12
    
    # Test Case 27: compute-fit with odd result=13, guaranteed, HT=1
    # 65 CPUs / 5 pods = 13 (stays as 13 since HT=1)
    run_test "compute-fit: guaranteed, HT=1, 65/5=13" \
        65 33 "internode" 5 0 "guaranteed" "none" 1 13
    
    # Test Case 28: fit - request 1 CPU, guaranteed, HT=1 (allowed - 1 full core)
    run_test "fit: 1 CPU requested (1 full core, HT=1), guaranteed" \
        64 32 "internode" 8 1 "guaranteed" "none" 1 1
    
    # Test Case 29: fit - request any number, guaranteed, HT=1 (allowed)
    run_test "fit: 7 CPUs requested, guaranteed, HT=1 (allowed)" \
        64 32 "internode" 4 7 "guaranteed" "none" 1 7
    
    echo -e "\n=========================================="
    echo "Edge cases and insufficient resources"
    echo "=========================================="
    
    # Test Case 30: Very high pod density, guaranteed, HT=2 (SHOULD FAIL - not enough CPUs)
    # 64 CPUs / 100 pods = 0.64 -> 0 (cannot allocate even one full core)
    run_test "Very high pod density, guaranteed, HT=2: 64/100=0 (SHOULD FAIL)" \
        64 32 "internode" 100 0 "guaranteed" "none" 2 "" true
    
    # Test Case 31: Results in 3, guaranteed rounds to 2, HT=2
    # 50 CPUs / 15 pods = 3.33 -> 2 (multiple of 2)
    run_test "Results in 3, guaranteed rounds to 2, HT=2: 50/15" \
        50 25 "internode" 15 0 "guaranteed" "none" 2 2
    
    # Test Case 32: Results in 5, guaranteed rounds to 4, HT=2
    # 50 CPUs / 9 pods = 5.55 -> 4 (multiple of 2)
    run_test "Results in 5, guaranteed rounds to 4, HT=2: 50/9" \
        50 25 "internode" 9 0 "guaranteed" "none" 2 4
    
    # Test Case 33: Results in 7, guaranteed rounds to 4, HT=4
    # 60 CPUs / 8 pods = 7.5 -> 4 (multiple of 4)
    run_test "Results in 7, guaranteed rounds to 4, HT=4: 60/8" \
        60 30 "internode" 8 0 "guaranteed" "none" 4 4
    
    # Test Case 34: Insufficient for one full core, HT=4 (SHOULD FAIL)
    # 64 CPUs / 20 pods = 3.2 -> 0 (cannot allocate 4 CPUs per pod)
    run_test "Insufficient for one full core, HT=4: 64/20=3 (SHOULD FAIL)" \
        64 32 "internode" 20 0 "guaranteed" "none" 4 "" true
    
    # Test Case 35: Just enough for one full core, HT=4
    # 64 CPUs / 16 pods = 4 (exactly one full core)
    run_test "Just enough for one full core, HT=4: 64/16=4" \
        64 32 "internode" 16 0 "guaranteed" "none" 4 4
    
    # Test Case 36: Burstable can work with 0 CPUs (edge case, allowed but not practical)
    # 64 CPUs / 100 pods = 0.64 -> 0 for burstable (technically allowed)
    run_test "Very high pod density, burstable, HT=2: 64/100=0 (allowed for burstable)" \
        64 32 "internode" 100 0 "burstable" "none" 2 0
    
    # Test Case 37: single-numa-node insufficient, guaranteed, HT=2 (SHOULD FAIL)
    # 32 CPUs per socket / 20 pods = 1.6 -> 0 (cannot allocate)
    run_test "single-numa-node insufficient, guaranteed, HT=2: 32/20=1 (SHOULD FAIL)" \
        64 32 "internode" 20 0 "guaranteed" "single-numa-node" 2 "" true
    
    # Test Case 38: single-numa-node just enough, guaranteed, HT=2
    # 32 CPUs per socket / 16 pods = 2 (exactly one full core)
    run_test "single-numa-node just enough, guaranteed, HT=2: 32/16=2" \
        64 32 "internode" 16 0 "guaranteed" "single-numa-node" 2 2
    
    # Test Case 39: Large system, HT=2
    # 128 CPUs / 9 pods = 14.22 -> 14 (multiple of 2)
    run_test "Large system guaranteed, HT=2: 128/9=14" \
        128 64 "internode" 9 0 "guaranteed" "none" 2 14
    
    # Test Case 40: intranode with HT=4
    # 64 CPUs / 8 pods (intranode: 4*2) = 8 (multiple of 4)
    run_test "intranode guaranteed, HT=4: 64/8=8" \
        64 32 "intranode" 4 0 "guaranteed" "none" 4 8
    
    # Test Case 41: fit - compute-fit mode demonstration
    run_test "compute-fit: 0 requested means auto-calculate, burstable" \
        64 32 "internode" 4 0 "burstable" "none" 2 16
    
    # Test Case 42: Exceeds limit even though multiple of cpus_per_core
    run_test "fit: 20 CPUs requested (multiple of 2 but exceeds), guaranteed, HT=2 (SHOULD FAIL)" \
        64 32 "internode" 4 20 "guaranteed" "none" 2 "" true
    
    # Test Case 43: fit - burstable requesting more than available (SHOULD FAIL)
    # 64 CPUs / 100 pods = 0.64 max per pod, requesting 1 exceeds this
    run_test "fit: 1 CPU requested but only 0 available per pod, burstable (SHOULD FAIL)" \
        64 32 "internode" 100 1 "burstable" "none" 2 "" true
    
    # Test Case 44: fit - burstable with valid small request
    run_test "fit: 1 CPU requested with enough resources, burstable" \
        64 32 "internode" 32 1 "burstable" "none" 2 1
    
    # Test Case 45: fit - burstable at exact available limit
    # 64 CPUs / 32 pods = 2 per pod, requesting 2
    run_test "fit: 2 CPUs requested at exact limit, burstable" \
        64 32 "internode" 32 2 "burstable" "none" 2 2
####
    # Test Case 46: fit - burstable at exact available limit
    # 64 CPUs / 4 pods = 2 per pod, requesting 2
    run_test "fit: 4 CPUs requested at exact limit, guaranteed" \
        66 20 "intranode" 4 4 "guaranteed" "none" 2 2

    
    echo -e "\n=========================================="
    echo "Test Summary"
    echo "=========================================="
    echo -e "Total Tests: $TOTAL_TESTS"
    echo -e "${GREEN}Passed: $PASSED_TESTS${NC}"
    echo -e "${RED}Failed: $FAILED_TESTS${NC}"
    echo "=========================================="
    
    if [[ $FAILED_TESTS -eq 0 ]]; then
        echo -e "${GREEN}All tests passed!${NC}"
        exit 0
    else
        echo -e "${RED}Some tests failed!${NC}"
        exit 1
    fi
else
    # script being sourced
    :
fi
